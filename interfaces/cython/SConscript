"""Cython-based Python Module"""
from buildutils import *

from string import Template

Import('env', 'build', 'install')

localenv = env.Clone()

cythonized = localenv.Command(
    'cantera/_cantera.cpp',
    'cantera/_cantera.pyx',
    '''${python_cmd} -c "import Cython.Build; Cython.Build.cythonize('${SOURCE}')"''')

for f in mglob(localenv, 'cantera', 'pyx', 'pxd'):
    localenv.Depends(cythonized, f)

for line in open('cantera/_cantera.pxd'):
    m = re.search(r'from "(cantera.*?)"', line)
    if m:
        localenv.Depends('cantera/_cantera.cpp', '#include/' + m.group(1))

dataFiles = localenv.RecursiveInstall('#interfaces/cython/cantera/data',
                                      '#build/data')
build(dataFiles)

testFiles = localenv.RecursiveInstall('#interfaces/cython/cantera/test/data',
                                      '#test/data')
build(testFiles)

# Get information needed to build the Python module
script = '\n'.join(("from distutils.sysconfig import *",
                    "import numpy",
                    "print(get_config_var('EXT_SUFFIX') or get_config_var('SO'))",
                    "print(get_config_var('INCLUDEPY'))",
                    "print(get_config_var('LDLIBRARY'))",
                    "print(get_config_var('prefix'))",
                    "print(get_python_version())",
                    "print(numpy.get_include())"))
info = getCommandOutput(localenv['python_cmd'], '-c', script)
module_ext, inc, pylib, prefix, py_version, numpy_include = info.splitlines()[-6:]
localenv.Prepend(CPPPATH=[Dir('#include'), inc, numpy_include])
localenv.Prepend(LIBS=localenv['cantera_libs'])

# Don't print deprecation warnings for internal Python changes.
# Only applies to Python 3.8. The field that is deprecated in Python 3.8
# and causes the warnings to appear will be removed in Python 3.9 so no
# further warnings should be issued.
if localenv['HAS_CLANG'] and parse_version(py_version) == parse_version('3.8'):
    localenv.Append(CXXFLAGS='-Wno-deprecated-declarations')

if localenv['OS'] == 'Darwin':
    localenv.Append(LINKFLAGS='-undefined dynamic_lookup')
elif localenv['OS'] == 'Windows':
    localenv.Append(LIBPATH=prefix+'/libs')
    if localenv['toolchain'] == 'mingw':
        localenv.Append(LIBS='python{}'.format(py_version.replace('.','')))
        if localenv['OS_BITS'] == 64:
            localenv.Append(CPPDEFINES='MS_WIN64')
        # fix for http://bugs.python.org/issue11566
        localenv.Append(CPPDEFINES={'_hypot':'hypot'})
elif localenv['OS'] == 'Cygwin':
    # extract 'pythonX.Y' from 'libpythonX.Y.dll.a'
    localenv.Append(LIBS=pylib[3:-6])

# Build the Python module
obj = localenv.SharedObject('#build/temp-py/_cantera', 'cantera/_cantera.cpp')
ext = localenv.LoadableModule('#build/python/cantera/_cantera{}'.format(module_ext),
                            obj, LIBPREFIX='', SHLIBSUFFIX=module_ext,
                            SHLIBPREFIX='', LIBSUFFIXES=[module_ext])
localenv['py_extension'] = ext[0].name

localenv.SubstFile('setup.py', 'setup.py.in')
build_cmd = ('cd interfaces/cython &&'
             ' $python_cmd_esc setup.py build --build-lib=../../build/python')
mod = build(localenv.Command('#build/python/cantera/__init__.py', 'setup.py',
                             build_cmd))
env['python_module'] = mod
env['python_extension'] = ext

UNITS = {
    "cp_mass": '"J/kg/K"', "cp_mole": '"J/kmol/K"', "cv_mass": '"J/kg/K"',
    "cv_mole": '"J/kmol/K"', "density_mass": '"kg/m**3"', "density_mole": '"kmol/m**3"',
    "enthalpy_mass": '"J/kg"', "enthalpy_mole": '"J/kmol"', "entropy_mass": '"J/kg/K"',
    "entropy_mole": '"J/kmol/K"', "gibbs_mass": '"J/kg"', "gibbs_mole": '"J/kmol"',
    "int_energy_mass": '"J/kg"', "int_energy_mole": '"J/kmol"',
    "volume_mass": '"m**3/kg"', "volume_mole": '"m**3/kmol"', "T": '"K"', "P": '"Pa"',
    "X": '"dimensionless"', "Y": '"dimensionless"', "Q": '"dimensionless"',
    "cp": '"J/K/" + self.basis_units', "cv": '"J/K/" + self.basis_units',
    "density": 'self.basis_units + "/m**3"', "h": '"J/" + self.basis_units',
    "s": '"J/K/" + self.basis_units', "g": '"J/" + self.basis_units',
    "u": '"J/" + self.basis_units', "v": '"m**3/" + self.basis_units',
    "H": '"J/" + self.basis_units', "V": '"m**3/" + self.basis_units',
    "S": '"J/K/" + self.basis_units', "D": 'self.basis_units + "/m**3"',
    "U": '"J/" + self.basis_units', "P_sat": '"Pa"', "T_sat": '"K"',
    "atomic_weight": '"kg/kmol"', "chemical_potentials": '"J/kmol"',
    "concentrations": '"kmol/m**3"', "critical_pressure": '"Pa"',
    "critical_temperature": '"K"', "electric_potential": '"V"',
    "electrochemical_potentials": '"J/kmol"', "isothermal_compressibility": '"1/Pa"',
    "max_temp": '"K"', "mean_molecular_weight": '"kg/kmol"', "min_temp": '"K"',
    "molecular_weights": '"kg/kmol"', "partial_molar_cp": '"J/kmol/K"',
    "partial_molar_enthalpies": '"J/kmol"', "partial_molar_entropies": '"J/kmol/K"',
    "partial_molar_int_energies": '"J/kmol"', "partial_molar_volumes": '"m**3/kmol"',
    "reference_pressure": '"Pa"', "thermal_expansion_coeff": '"1/K"'
}

getter_template = Template("""
    @property
    def ${name}(self):
        return Q_(self._phase.${name}, ${units})
""")

getter_properties = [
    "density_mass", "density_mole", "enthalpy_mass", "enthalpy_mole", "entropy_mass",
    "entropy_mole", "int_energy_mass", "int_energy_mole", "volume_mass", "volume_mole",
    "gibbs_mass", "gibbs_mole", "cp_mass", "cp_mole", "P", "P_sat", "T", "T_sat",
    "atomic_weight", "chemical_potentials", "concentrations", "critical_pressure",
    "critical_temperature", "electric_potential", "electrochemical_potentials",
    "isothermal_compressibility", "max_temp", "mean_molecular_weight", "min_temp",
    "molecular_weights", "partial_molar_cp", "partial_molar_enthalpies",
    "partial_molar_entropies", "partial_molar_int_energies", "partial_molar_volumes",
    "reference_pressure", "thermal_expansion_coeff", "cp", "cv", "density",
    "h", "s", "g", "u", "v"
]

getter_string = "".join(
    getter_template.substitute(name=name, units=UNITS[name]) for name in getter_properties
)
pf_getter_string = getter_template.substitute(name="Q", units=UNITS["Q"])

setter_template = Template("""
    @property
    def ${name}(self):
        ${n0}, ${n1} = self._phase.${name}
        return Q_(${n0}, ${u0}), Q_(${n1}, ${u1})

    @${name}.setter
    def ${name}(self, value):
        ${n0} = value[0].to(${u0}) if value[0] is not None else self.${n0}
        ${n1} = value[1].to(${u1}) if value[1] is not None else self.${n1}
        self._phase.${name} = ${n0}.magnitude, ${n1}.magnitude
""")

setter_properties = ["TP", "DP", "HP", "SP", "SV", "TD", "UV"]
pf_setter_properties = ["PQ", "TQ", "PV", "SH", "ST", "TH", "TV", "UP", "VH"]

setter_string = "".join(
    setter_template.substitute(name=name, n0=name[0], u0=UNITS[name[0]], n1=name[1], u1=UNITS[name[1]]) for name in setter_properties
)
pf_setter_string = "".join(
    setter_template.substitute(name=name, n0=name[0], u0=UNITS[name[0]], n1=name[1], u1=UNITS[name[1]]) for name in pf_setter_properties
)

setter1_template = Template("""
    @property
    def ${name}(self):
        ${n0}, ${n1}, ${n2} = self._phase.${name}
        return Q_(${n0}, ${u0}), Q_(${n1}, ${u1}), Q_(${n2}, ${u2})

    @${name}.setter
    def ${name}(self, value):
        ${n0} = value[0].to(${u0}) if value[0] is not None else self.${n0}
        ${n1} = value[1].to(${u1}) if value[1] is not None else self.${n1}
        if value[2] is not None:
            try:
                ${n2} = value[2].to(${u2}).magnitude
            except AttributeError:
                ${n2} = value[2]
        else:
            ${n2} = self.${n2}.magnitude
        self._phase.${name} = ${n0}.magnitude, ${n1}.magnitude, ${n2}
""")

setter1_properties = [
    "TPX", "TPY", "DPX", "DPY", "HPX", "HPY", "SPX", "SPY", "SVX", "SVY",
    "TDX", "TDY", "UVX", "UVY"
]
pf_setter1_properties = ["TPQ", "DPQ", "HPQ", "SPQ", "SVQ", "TDQ", "UVQ"]

setter1_string = "".join(
    setter1_template.substitute(name=name, n0=name[0], u0=UNITS[name[0]], n1=name[1], u1=UNITS[name[1]], n2=name[2], u2=UNITS[name[2]]) for name in setter1_properties
)
pf_setter1_string = "".join(
    setter1_template.substitute(name=name, n0=name[0], u0=UNITS[name[0]], n1=name[1], u1=UNITS[name[1]], n2=name[2], u2=UNITS[name[2]]) for name in pf_setter1_properties
)

solution_properties = "".join([getter_string, setter_string, setter1_string])
pf_properties = "".join([pf_getter_string, pf_setter_string, pf_setter1_string])

localenv["solution_properties"] = solution_properties.strip()
localenv["purefluid_properties"] = pf_properties.strip()
localenv.SubstFile("cantera/units/solution.py", "cantera/units/solution.py.in")

localenv.Depends(mod, ext)
localenv.Depends(mod, dataFiles + testFiles)
localenv.Depends(ext, localenv['cantera_staticlib'])

for f in (mglob(localenv, 'cantera', 'py') +
          mglob(localenv, 'cantera/units', 'py') +
          mglob(localenv, 'cantera/test', 'py') +
          mglob(localenv, 'cantera/examples/kinetics', 'py') +
          mglob(localenv, 'cantera/examples/multiphase', 'py') +
          mglob(localenv, 'cantera/examples/onedim', 'py') +
          mglob(localenv, 'cantera/examples/reactors', 'py') +
          mglob(localenv, 'cantera/examples/surface_chemistry', 'py') +
          mglob(localenv, 'cantera/examples/thermo', 'py') +
          mglob(localenv, 'cantera/examples/transport', 'py')):
    localenv.Depends(mod, f)

# Determine installation path and install the Python module
if localenv['python_prefix'] == 'USER':
    # Install to the OS-dependent user site-packages directory
    extra = '--user'
    if localenv['OS'] == 'Darwin':
        extra += ' --prefix=""'
elif localenv['python_prefix']:
    # A specific location for the Cantera python module has been given
    if localenv['debian'] and localenv.subst('${python_prefix}') == '/usr/local':
        # Installation to /usr/local is the default on Debian-based distributions
        extra = ''
    elif localenv['OS'] == 'Darwin':
        extra = localenv.subst(' --prefix=${python_prefix}')
    elif localenv['libdirname'] != 'lib':
        # 64-bit RHEL / Fedora etc. or e.g. x32 Gentoo profile
        extra = localenv.subst(
            ' --prefix=${{python_prefix}}'
            ' --install-lib=${{python_prefix}}/${{libdirname}}/python{}/site-packages'.format(py_version))
    else:
        extra = '--user'
        localenv.AppendENVPath(
            'PYTHONUSERBASE',
            normpath(localenv.subst('$python_prefix')))
else:
    # Install Python module in the default location
    extra = ''

env['python_module_loc'] = '<unspecified>'
if localenv['PYTHON_INSTALLER'] == 'direct':
    mod_inst = install(localenv.Command, 'dummy', mod,
                       build_cmd + ' install ' + extra +
                       ' --record=../../build/python-installed-files.txt' +
                       ' --single-version-externally-managed')
    global_env = env
    def find_module_dir(target, source, env):
        check = pjoin('cantera', '__init__.py')
        for filename in open('build/python-installed-files.txt').readlines():
            filename = filename.strip()
            if filename.endswith(check):
                filename = filename.replace(check, '')
                global_env['python_module_loc'] = normpath(filename)
                break
    localenv.AlwaysBuild(localenv.AddPostAction(mod_inst, find_module_dir))
    env['install_python_action'] = mod_inst
elif localenv['PYTHON_INSTALLER'] == 'debian':
    extra = localenv.subst(' --root=${python_prefix}')
    install(localenv.Command, 'dummy', mod,
            build_cmd + ' install --install-layout=deb --no-compile ' + extra)
elif localenv['PYTHON_INSTALLER'] == 'binary':
    install(localenv.Command, 'dummy', mod,
            build_cmd + ' bdist_msi --dist-dir=../..' +
            ' --target-version=' + py_version)
