"""Cython-based Python Module"""
from buildutils import *

from string import Template

Import('env', 'build', 'install')

localenv = env.Clone()

cythonized = localenv.Command(
    'cantera/_cantera.cpp',
    'cantera/_cantera.pyx',
    '''${python_cmd} -c "import Cython.Build; Cython.Build.cythonize('${SOURCE}')"''')

for f in mglob(localenv, 'cantera', 'pyx', 'pxd'):
    localenv.Depends(cythonized, f)

for line in open('cantera/_cantera.pxd'):
    m = re.search(r'from "(cantera.*?)"', line)
    if m:
        localenv.Depends('cantera/_cantera.cpp', '#include/' + m.group(1))

dataFiles = localenv.RecursiveInstall('#interfaces/cython/cantera/data',
                                      '#build/data')
build(dataFiles)

testFiles = localenv.RecursiveInstall('#interfaces/cython/cantera/test/data',
                                      '#test/data')
build(testFiles)

# Get information needed to build the Python module
script = '\n'.join(("from distutils.sysconfig import *",
                    "import numpy",
                    "print(get_config_var('EXT_SUFFIX') or get_config_var('SO'))",
                    "print(get_config_var('INCLUDEPY'))",
                    "print(get_config_var('LDLIBRARY'))",
                    "print(get_config_var('prefix'))",
                    "print(get_python_version())",
                    "print(numpy.get_include())"))
info = getCommandOutput(localenv['python_cmd'], '-c', script)
module_ext, inc, pylib, prefix, py_version, numpy_include = info.splitlines()[-6:]
localenv.Prepend(CPPPATH=[Dir('#include'), inc, numpy_include])
localenv.Prepend(LIBS=localenv['cantera_libs'])

# Don't print deprecation warnings for internal Python changes.
# Only applies to Python 3.8. The field that is deprecated in Python 3.8
# and causes the warnings to appear will be removed in Python 3.9 so no
# further warnings should be issued.
if localenv['HAS_CLANG'] and parse_version(py_version) == parse_version('3.8'):
    localenv.Append(CXXFLAGS='-Wno-deprecated-declarations')

if localenv['OS'] == 'Darwin':
    localenv.Append(LINKFLAGS='-undefined dynamic_lookup')
elif localenv['OS'] == 'Windows':
    localenv.Append(LIBPATH=prefix+'/libs')
    if localenv['toolchain'] == 'mingw':
        localenv.Append(LIBS='python{}'.format(py_version.replace('.','')))
        if localenv['OS_BITS'] == 64:
            localenv.Append(CPPDEFINES='MS_WIN64')
        # fix for http://bugs.python.org/issue11566
        localenv.Append(CPPDEFINES={'_hypot':'hypot'})
elif localenv['OS'] == 'Cygwin':
    # extract 'pythonX.Y' from 'libpythonX.Y.dll.a'
    localenv.Append(LIBS=pylib[3:-6])

# Build the Python module
obj = localenv.SharedObject('#build/temp-py/_cantera', 'cantera/_cantera.cpp')
ext = localenv.LoadableModule('#build/python/cantera/_cantera{}'.format(module_ext),
                            obj, LIBPREFIX='', SHLIBSUFFIX=module_ext,
                            SHLIBPREFIX='', LIBSUFFIXES=[module_ext])
localenv['py_extension'] = ext[0].name

localenv.SubstFile('setup.py', 'setup.py.in')
build_cmd = ('cd interfaces/cython &&'
             ' $python_cmd_esc setup.py build --build-lib=../../build/python')
mod = build(localenv.Command('#build/python/cantera/__init__.py', 'setup.py',
                             build_cmd))
env['python_module'] = mod
env['python_extension'] = ext

UNITS = {
    "cp_mass": '"J/kg/K"', "cp_mole": '"J/kmol/K"', "cv_mass": '"J/kg/K"',
    "cv_mole": '"J/kmol/K"', "density_mass": '"kg/m**3"', "density_mole": '"kmol/m**3"',
    "enthalpy_mass": '"J/kg"', "enthalpy_mole": '"J/kmol"', "entropy_mass": '"J/kg/K"',
    "entropy_mole": '"J/kmol/K"', "gibbs_mass": '"J/kg"', "gibbs_mole": '"J/kmol"',
    "int_energy_mass": '"J/kg"', "int_energy_mole": '"J/kmol"',
    "volume_mass": '"m**3/kg"', "volume_mole": '"m**3/kmol"', "T": '"K"', "P": '"Pa"',
    "X": '"dimensionless"', "Y": '"dimensionless"', "Q": '"dimensionless"',
    "cp": '"J/K/" + self.basis_units', "cv": '"J/K/" + self.basis_units',
    "density": 'self.basis_units + "/m**3"', "h": '"J/" + self.basis_units',
    "s": '"J/K/" + self.basis_units', "g": '"J/" + self.basis_units',
    "u": '"J/" + self.basis_units', "v": '"m**3/" + self.basis_units',
    "H": '"J/" + self.basis_units', "V": '"m**3/" + self.basis_units',
    "S": '"J/K/" + self.basis_units', "D": 'self.basis_units + "/m**3"',
    "U": '"J/" + self.basis_units', "P_sat": '"Pa"', "T_sat": '"K"',
    "atomic_weight": '"kg/kmol"', "chemical_potentials": '"J/kmol"',
    "concentrations": '"kmol/m**3"', "critical_pressure": '"Pa"',
    "critical_temperature": '"K"', "electric_potential": '"V"',
    "electrochemical_potentials": '"J/kmol"', "isothermal_compressibility": '"1/Pa"',
    "max_temp": '"K"', "mean_molecular_weight": '"kg/kmol"', "min_temp": '"K"',
    "molecular_weights": '"kg/kmol"', "partial_molar_cp": '"J/kmol/K"',
    "partial_molar_enthalpies": '"J/kmol"', "partial_molar_entropies": '"J/kmol/K"',
    "partial_molar_int_energies": '"J/kmol"', "partial_molar_volumes": '"m**3/kmol"',
    "reference_pressure": '"Pa"', "thermal_expansion_coeff": '"1/K"'
}

getter_properties = [
    "density_mass", "density_mole", "enthalpy_mass", "enthalpy_mole", "entropy_mass",
    "entropy_mole", "int_energy_mass", "int_energy_mole", "volume_mass", "volume_mole",
    "gibbs_mass", "gibbs_mole", "cp_mass", "cp_mole", "cv_mass", "cv_mole", "P",
    "P_sat", "T", "T_sat", "atomic_weight", "chemical_potentials", "concentrations",
    "critical_pressure", "critical_temperature", "electric_potential",
    "electrochemical_potentials", "isothermal_compressibility", "max_temp",
    "mean_molecular_weight", "min_temp", "molecular_weights", "partial_molar_cp",
    "partial_molar_enthalpies", "partial_molar_entropies", "partial_molar_int_energies",
    "partial_molar_volumes", "reference_pressure", "thermal_expansion_coeff", "cp",
    "cv", "density", "h", "s", "g", "u", "v"
]

getter_template = Template("""
    @property
    def ${name}(self):
        return Q_(self._phase.${name}, ${units})
""")

thermophase_getters = []
for name in getter_properties:
    thermophase_getters.append(getter_template.substitute(name=name, units=UNITS[name]))

setter_2_template = Template("""
    @property
    def ${name}(self):
        ${n0}, ${n1} = self._phase.${name}
        return Q_(${n0}, ${u0}), Q_(${n1}, ${u1})

    @${name}.setter
    def ${name}(self, value):
        try:
            ${n0} = value[0].to(${u0}) if value[0] is not None else self.${n0}
            ${n1} = value[1].to(${u1}) if value[1] is not None else self.${n1}
        except AttributeError as e:
            # The 'to' attribute missing means this isn't a pint Quantity
            if "'to'" in str(e):
                raise CanteraError(
                    f"Values ({value}) must be instances of pint.Quantity classes"
                ) from None
            else:
                raise
        self._phase.${name} = ${n0}.magnitude, ${n1}.magnitude
""")

tp_setter_2_properties = ["TP", "DP", "HP", "SP", "SV", "TD", "UV"]
pf_setter_2_properties = ["PQ", "TQ", "PV", "SH", "ST", "TH", "TV", "UP", "VH"]

thermophase_2_setters = []
for name in tp_setter_2_properties:
    d = dict(name=name, n0=name[0], u0=UNITS[name[0]], n1=name[1], u1=UNITS[name[1]])
    thermophase_2_setters.append(setter_2_template.substitute(d))

purefluid_2_setters = []
for name in pf_setter_2_properties:
    d = dict(name=name, n0=name[0], u0=UNITS[name[0]], n1=name[1], u1=UNITS[name[1]])
    purefluid_2_setters.append(setter_2_template.substitute(d))

setter_3_template = Template("""
    @property
    def ${name}(self):
        ${n0}, ${n1}, ${n2} = self._phase.${name}
        return Q_(${n0}, ${u0}), Q_(${n1}, ${u1}), Q_(${n2}, ${u2})

    @${name}.setter
    def ${name}(self, value):
        try:
            ${n0} = value[0].to(${u0}) if value[0] is not None else self.${n0}
            ${n1} = value[1].to(${u1}) if value[1] is not None else self.${n1}
        except AttributeError as e:
            # The 'to' attribute missing means this isn't a pint Quantity
            if "'to'" in str(e):
                raise CanteraError(
                    f"Values ({value}) must be instances of pint.Quantity classes"
                ) from None
            else:
                raise
        if value[2] is not None:
            try:
                ${n2} = value[2].to(${u2}).magnitude
            except AttributeError:
                ${n2} = value[2]
        else:
            ${n2} = self.${n2}.magnitude
        self._phase.${name} = ${n0}.magnitude, ${n1}.magnitude, ${n2}
""")

tp_setter_3_properties = [
    "TPX", "TPY", "DPX", "DPY", "HPX", "HPY", "SPX", "SPY", "SVX", "SVY", "TDX", "TDY",
    "UVX", "UVY"
]

thermophase_3_setters = []
for name in tp_setter_3_properties:
    d = dict(name=name, n0=name[0], u0=UNITS[name[0]], n1=name[1], u1=UNITS[name[1]],
             n2=name[2], u2=UNITS[name[2]])
    thermophase_3_setters.append(setter_3_template.substitute(d))

getter_3_template = Template("""
    @property
    def ${name}(self):
        ${n0}, ${n1}, ${n2} = self._phase.${name}
        return Q_(${n0}, ${u0}), Q_(${n1}, ${u1}), Q_(${n2}, ${u2})
""")

pf_getter_3_properties = ["DPQ", "HPQ", "SPQ", "SVQ", "TDQ", "UVQ"]

purefluid_3_getters = []
for name in pf_getter_3_properties:
    d = dict(name=name, n0=name[0], u0=UNITS[name[0]], n1=name[1], u1=UNITS[name[1]],
             n2=name[2], u2=UNITS[name[2]])
    purefluid_3_getters.append(getter_3_template.substitute(d))


def recursive_join(*args, joiner=""):
    result = ""
    for arg in args:
        result = result + joiner.join(arg)
    return result


thermophase_properties = recursive_join(thermophase_getters, thermophase_2_setters,
                                        thermophase_3_setters)
purefluid_properties = recursive_join(purefluid_2_setters, purefluid_3_getters)

common_properties = """
    def __getattr__(self, name):
        return getattr(self._phase, name)

    def __setattr__(self, name, value):
        if name in dir(self):
            object.__setattr__(self, name, value)
        else:
            setattr(self._phase, name, value)

    @property
    def basis_units(self):
        if self._phase.basis == "mass":
            return "kg"
        else:
            return "kmol"

    @property
    def X(self):
        X = self._phase.X
        return Q_(X, "dimensionless")

    @X.setter
    def X(self, value):
        if value is not None:
            try:
                X = value.to("dimensionless").magnitude
            except AttributeError:
                X = value
        else:
            X = self.X.magnitude
        self._phase.X = X

    @property
    def Y(self):
        Y = self._phase.Y
        return Q_(Y, "dimensionless")

    @Y.setter
    def Y(self, value):
        if value is not None:
            try:
                Y = value.to("dimensionless").magnitude
            except AttributeError:
                Y = value
        else:
            Y = self.Y.magnitude
        self._phase.Y = Y
"""

localenv["common_properties"] = common_properties.strip()
localenv["thermophase_properties"] = thermophase_properties.strip()
localenv["purefluid_properties"] = purefluid_properties.strip()
localenv.SubstFile("cantera/units/solution.py", "cantera/units/solution.py.in")

localenv.Depends(mod, ext)
localenv.Depends(mod, dataFiles + testFiles)
localenv.Depends(ext, localenv['cantera_staticlib'])

for f in (mglob(localenv, 'cantera', 'py') +
          mglob(localenv, 'cantera/units', 'py') +
          mglob(localenv, 'cantera/test', 'py') +
          mglob(localenv, 'cantera/examples/kinetics', 'py') +
          mglob(localenv, 'cantera/examples/multiphase', 'py') +
          mglob(localenv, 'cantera/examples/onedim', 'py') +
          mglob(localenv, 'cantera/examples/reactors', 'py') +
          mglob(localenv, 'cantera/examples/surface_chemistry', 'py') +
          mglob(localenv, 'cantera/examples/thermo', 'py') +
          mglob(localenv, 'cantera/examples/transport', 'py')):
    localenv.Depends(mod, f)

# Determine installation path and install the Python module
if localenv['python_prefix'] == 'USER':
    # Install to the OS-dependent user site-packages directory
    extra = '--user'
    if localenv['OS'] == 'Darwin':
        extra += ' --prefix=""'
elif localenv['python_prefix']:
    # A specific location for the Cantera python module has been given
    if localenv['debian'] and localenv.subst('${python_prefix}') == '/usr/local':
        # Installation to /usr/local is the default on Debian-based distributions
        extra = ''
    elif localenv['OS'] == 'Darwin':
        extra = localenv.subst(' --prefix=${python_prefix}')
    elif localenv['libdirname'] != 'lib':
        # 64-bit RHEL / Fedora etc. or e.g. x32 Gentoo profile
        extra = localenv.subst(
            ' --prefix=${{python_prefix}}'
            ' --install-lib=${{python_prefix}}/${{libdirname}}/python{}/site-packages'.format(py_version))
    else:
        extra = '--user'
        localenv.AppendENVPath(
            'PYTHONUSERBASE',
            normpath(localenv.subst('$python_prefix')))
else:
    # Install Python module in the default location
    extra = ''

env['python_module_loc'] = '<unspecified>'
if localenv['PYTHON_INSTALLER'] == 'direct':
    mod_inst = install(localenv.Command, 'dummy', mod,
                       build_cmd + ' install ' + extra +
                       ' --record=../../build/python-installed-files.txt' +
                       ' --single-version-externally-managed')
    global_env = env
    def find_module_dir(target, source, env):
        check = pjoin('cantera', '__init__.py')
        for filename in open('build/python-installed-files.txt').readlines():
            filename = filename.strip()
            if filename.endswith(check):
                filename = filename.replace(check, '')
                global_env['python_module_loc'] = normpath(filename)
                break
    localenv.AlwaysBuild(localenv.AddPostAction(mod_inst, find_module_dir))
    env['install_python_action'] = mod_inst
elif localenv['PYTHON_INSTALLER'] == 'debian':
    extra = localenv.subst(' --root=${python_prefix}')
    install(localenv.Command, 'dummy', mod,
            build_cmd + ' install --install-layout=deb --no-compile ' + extra)
elif localenv['PYTHON_INSTALLER'] == 'binary':
    install(localenv.Command, 'dummy', mod,
            build_cmd + ' bdist_msi --dist-dir=../..' +
            ' --target-version=' + py_version)
